# Cryptocurrency Wallet Backend

Welcome to the Cryptocurrency Wallet Backend project! This robust and secure Spring Boot application serves as the core infrastructure for a modern cryptocurrency wallet. It handles essential functionalities such as user management, wallet creation, secure storage of private keys, and the processing of cryptographic transactions, all exposed via a well-defined RESTful API.

Built with security and scalability in mind, this backend leverages industry-standard cryptographic algorithms and follows best practices for authentication and authorization. It's designed to be stateless and compatible with distributed systems, providing a solid foundation for a performant and reliable wallet application.

## ðŸ”¥ New in Latest Update

> **feat: Implement Event-Driven Architecture & Transaction Chaining**

This release introduces architectural improvements and blockchain-style enhancements:

- **Event-Driven Architecture (EDA):**
    - Introduced `UserRegisteredEvent`, `WalletCreatedEvent`, and `TransactionCreatedEvent`.
    - `UserService` and `WalletService` publish events after successful actions.
    - `AuditService` listens to events to handle audit logging, promoting modularity and real-time insights.

- **Transaction Chaining & Merkle Tree:**
    - Added `BlockChain` component with Merkle Root support.
    - Transactions are batched (threshold: 8) into blocks, each chaining to the previous one.
    - Ensures immutability, auditability, and data integrity.

- **Enhanced Exception Handling:**
    - Mapped custom exceptions with `@ResponseStatus` annotations.
    - Expanded `GlobalExceptionHandler` for specific error responses.
    - Added detailed logging for easier debugging.

- **Service Enhancements:**
    - Injected `ApplicationEventPublisher` and `BlockChain` into services.
    - Added `@Transactional` for atomicity.
    - Adjusted default balance handling in `WalletDocument`.

## Features

This backend offers a rich set of features, designed to provide a secure and functional base for any cryptocurrency wallet:

### User Authentication & Authorization:

- **User Registration**: Allows new users to securely sign up with username, email, and password. Robust validation is applied to ensure data integrity and security (e.g., minimum password length, valid email format).
- **User Login**: Authenticates existing users and issues a JSON Web Token (JWT) upon successful login. This token is used for subsequent requests to protected resources.
- **JWT-based Security**: Implements stateless authentication using JWTs, providing a highly scalable and secure mechanism. Spring Security is configured to validate incoming JWTs and authorize access to API endpoints.
- **Password Hashing**: User passwords are securely stored using BCrypt hashing, protecting against brute-force attacks and database breaches.
- **Role-Based Access (Basic)**: Authenticated users are assigned a default ROLE_USER, enabling access to protected endpoints.

### Wallet Management:

- **Wallet Creation**: Enables authenticated users to create a new cryptocurrency wallet linked to their user account. Each wallet is assigned a unique public address (derived from its public key).
- **Secure Private Key Storage**: Private keys are generated using strong cryptographic techniques (ECDSA) and are then encrypted using AES-256 GCM before being stored in the database. This ensures that even if the database is compromised, private keys remain protected.
- **Wallet Retrieval**: Allows users to fetch the details of their wallets, including their public address and current balances.
- **Multi-Currency Balance Support**: Wallets can maintain balances across different cryptocurrencies (e.g., USD, BTC).

### Transaction Processing:

- **Send Transaction**: Facilitates the initiation of cryptocurrency transfers between wallets.
- **Cryptographic Signature Verification**: Each transaction requires a digital signature generated by the sender's private key. The backend rigorously verifies this signature using the sender's public key (fromAddress) to ensure:
    - **Authentication**: The transaction genuinely originates from the stated sender.
    - **Integrity**: The transaction data has not been tampered with in transit.
    - **Replay Attack Protection**: Transactions are uniquely identified by their signature, preventing the same transaction from being processed multiple times.
- **Atomic Balance Updates**: Balances of both sender and receiver wallets are updated atomically within a transaction, ensuring data consistency even in concurrent scenarios.
- **Fund Validation**: Checks for sufficient funds in the sender's wallet before processing a transaction.

### Cryptographic Operations:

- **AES-256 GCM Encryption/Decryption**: Used for symmetric encryption of sensitive data like private keys, providing confidentiality and authenticated encryption.
- **ECDSA (Elliptic Curve Digital Signature Algorithm) with secp256k1**: Employed for generating and verifying digital signatures for transactions, ensuring non-repudiation and integrity. The Bouncy Castle cryptography provider is integrated for these advanced algorithms.

### RESTful API Design:

- Clean, intuitive, and standard-compliant RESTful API endpoints for all operations.
- Uses appropriate HTTP status codes (e.g., 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error).

### Robust Error Handling:

- Implements a global exception handler to gracefully catch and translate internal errors into meaningful, client-friendly API responses.
- Custom exceptions (e.g., InvalidTransactionException, UserAlreadyExistsException, UserNotFoundException) provide specific error contexts.
- **Logging**: Comprehensive logging using SLF4j and Logback helps monitor application behavior and diagnose issues.
- **API Documentation**: Integrated with SpringDoc OpenAPI (Swagger UI) for automatic API documentation generation, making it easy to explore and interact with the endpoints.

## Technologies Used

- **Backend Framework**: Spring Boot 3.2.5 (Java 17)
- **Database**: MongoDB (NoSQL document database)
- **Web Server**: Embedded Tomcat (provided by Spring Boot)

### Security:

- Spring Security: Core security framework.
- JJWT (JSON Web Token): Library for creating and validating JWTs.
- BCrypt: Password hashing algorithm.
- Bouncy Castle: Java cryptography API for advanced algorithms like ECDSA (secp256k1).

### Build Tool: Apache Maven

### Containerization: Docker, Docker Compose

### Utilities:

- Lombok: Reduces boilerplate code.
- SLF4j / Logback: Logging facade and implementation.

### Testing:

- JUnit 5: Unit testing framework.
- Mockito: Mocking framework for unit tests.
- Spring Boot Test: Integration testing support for Spring Boot applications.
- Spring Security Test: Utilities for testing Spring Security configurations.
- Postman: For manual and automated API integration testing.

---

## Getting Started

Follow these steps to get the Cryptocurrency Wallet Backend up and running on your local machine.

### Prerequisites

Ensure you have the following installed:

- Java Development Kit (JDK) 17 or higher
- Apache Maven 3.x
- Docker Desktop (includes Docker Engine and Docker Compose)
- Git
- Postman (or any API testing client)

### 1. Clone the Repository

```bash
git clone https://github.com/TheAlchemistNerd/Cryptocurrency-Wallet.git
cd Cryptocurrency-Wallet
```

### 2. Environment Variables Setup (Crucial!)

This project relies on environment variables for sensitive cryptographic keys. **Do NOT** hardcode these into your application code.

You have two critical secrets:

- `CRYPTO_AES_SECRET`: A 32-byte (256-bit) key, Base64-encoded, used for AES encryption/decryption of private keys.
- `JWT_SECRET_KEY`: A 32-byte (256-bit) key, Base64-encoded, used for signing JWTs (HMAC-SHA256).

**How to Generate Secure Keys:**

Use the provided `KeyGenerator` utility class to generate cryptographically strong, Base64-encoded keys:

```bash
# Compile the KeyGenerator utility
mvn compile

# Run the KeyGenerator
java -cp target/classes com.cryptowallet.tool.KeyGenerator
```

This will output two Base64-encoded strings. Copy these values carefully.

**Configuration for Development:**

For local development and testing, you can use an `.env` file (for Docker Compose) or set them directly in your IntelliJ IDEA Run Configuration.

#### a) Using `.env` for Docker Compose:

Create a file named `.env` (or `env.test` if your `docker-compose.yml` references it as `env_file: .env`) in the root directory of your project (where `docker-compose.yml` is located).

```
# .env file example (replace with your generated keys)
SPRING_PROFILES_ACTIVE=test
CRYPTO_AES_SECRET=YOUR_GENERATED_BASE64_AES_KEY_HERE
JWT_SECRET_KEY=YOUR_GENERATED_BASE64_JWT_KEY_HERE
JWT_EXPIRATION=3600000
```

Make sure to replace the placeholders with your actual values and **no trailing spaces**.

#### b) Setting in IntelliJ IDEA Run Configuration:

Go to **Run > Edit Configurations...**

- Select your `CryptoWalletApplication`.
- In the *Environment variables* field, click the `...` button.
- Add:

```
SPRING_PROFILES_ACTIVE=test
CRYPTO_AES_SECRET=YOUR_GENERATED_BASE64_AES_KEY_HERE
JWT_SECRET_KEY=YOUR_GENERATED_BASE64_JWT_KEY_HERE
JWT_EXPIRATION=3600000
```

### 3. Run the Application

#### Option A: Using Docker Compose (Recommended for Local Development)

This will start both your MongoDB database and Spring Boot app in separate Docker containers.

```bash
docker-compose up -d
```

You can check status with:

```bash
docker-compose ps
docker-compose logs -f
```

The app will be available at [http://localhost:8080](http://localhost:8080)

To stop:

```bash
docker-compose down
```

#### Option B: Running Locally (Requires Local MongoDB Instance)

Ensure MongoDB is running on `localhost:27017`.

```bash
mvn clean install
mvn spring-boot:run
```

App starts on port `8080`.

---

## API Endpoints & Usage

Once the application is running, you can interact with its REST API using Postman or a similar tool. The API documentation is also available via Swagger UI.

**Base URL**: `http://localhost:8080/api`

---

## API Documentation (Swagger UI)

Access interactive API documentation at:

**[http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)**

This provides a complete overview of all endpoints, expected request/response schemas, and allows you to test them directly from your browser.

---

## 1. User Endpoints (`/api/users`)

### `POST /api/users/register` - Register a new user

**Description**: Creates a new user account.

- **Method**: POST
- **URL**: `http://localhost:8080/api/users/register`
- **Headers**: `Content-Type: application/json`
- **Body (raw, JSON)**:

```json
{
  "userName": "testuser",
  "email": "test@example.com",
  "password": "strongPassword123"
}
```

**Expected Response**: 201 Created with UserDTO

```json
{
  "id": "60c72b2f9f1b2c001f8e4d6c",
  "userName": "testuser",
  "email": "test@example.com"
}
```

---

### `POST /api/users/login` - Authenticate user and get JWT

**Description**: Authenticates a user and returns a JWT token for accessing protected resources.

- **Method**: POST
- **URL**: `http://localhost:8080/api/users/login`
- **Headers**: `Content-Type: application/json`
- **Body (raw, JSON)**:

```json
{
  "userName": "testuser",
  "password": "strongPassword123"
}
```

**Expected Response**: 200 OK with LoginResponseDTO

```json
{
  "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWJqZWN0Ijo..."
}
```

Use this token for all future requests with:

```http
Authorization: Bearer <your_jwt_token>
```

---

## 2. Wallet Endpoints (`/api/wallets`)

**These endpoints require JWT-based authentication.**

### `POST /api/users/{userId}/wallets` - Create wallet

- **Method**: POST
- **Authorization**: Bearer Token
- **Headers**: `Content-Type: application/json`
- **Body**: `{}`
- **URL**: `http://localhost:8080/api/users/{userId}/wallets`

**Expected Response**:

```json
{
  "id": "60c72b2f9f1b2c001f8e4d6c",
  "userId": "60c72b2f9f1b2c001f8e4d6c",
  "address": "MFwYFwEOZIJzJCAQYFK4EEAAoD0QGAEZ0R+P1DkDQAzQ...",
  "balances": {
    "USD": 1000.00
  }
}
```

---

### `GET /api/wallets/{walletId}` - Get wallet by ID

- **Method**: GET
- **Authorization**: Bearer Token
- **URL**: `http://localhost:8080/api/wallets/{walletId}`

**Expected Response**:

```json
{
  "id": "60c72b2f9f1b2c001f8e4d6c",
  "userId": "60c72b2f9f1b2c001f8e4d6c",
  "address": "MFwYFwEOZIJzJCAQYFK4EEAAoD0QGAEZ0R+P1DkDQAzQ...",
  "balances": {
    "USD": 1000.00
  }
}
```

---

## 3. Transaction Endpoints (`/api/transactions`)

### `POST /api/transactions/send` - Send transaction

- **Method**: POST
- **Authorization**: Bearer Token
- **Headers**: `Content-Type: application/json`
- **URL**: `http://localhost:8080/api/transactions/send`
- **Body**:

```json
{
  "fromAddress": "YOUR_SENDER_WALLET_PUBLIC_ADDRESS_HERE",
  "toAddress": "RECEIVER_PUBLIC_KEY_OF_ANOTHER_WALLET",
  "amount": 50.0,
  "currency": "USD",
  "signature": "DUMMY_SIGNATURE_FOR_TESTING_BYPASS"
}
```

**Expected Response (with signature bypass)**:

```json
{
  "id": "transaction-id-xyz",
  "fromAddress": "YOUR_SENDER_WALLET_PUBLIC_ADDRESS_HERE",
  "toAddress": "RECEIVER_PUBLIC_KEY_OF_ANOTHER_WALLET",
  "amount": 50.0,
  "currency": "USD",
  "signature": "DUMMY_SIGNATURE_FOR_TESTING_BYPASS",
  "timestamp": "2025-06-29T10:30:00Z"
}
```

---

## Key Generation Utility

Located at:

```
src/main/java/com/cryptowallet/tool/KeyGenerator.java
```

To run:

```bash
cd Cryptocurrency-Wallet
mvn compile
java -cp target/classes com.cryptowallet.tool.KeyGenerator
```

Use the output in your `.env` or IntelliJ environment variables.

---

## Testing

### Unit Tests

- Location: `src/test/java/com/cryptowallet/...`
- Frameworks: JUnit 5, Mockito, Spring Boot Test
- Run with:

```bash
mvn test
```

Covers:

- `TransactionControllerTest`
- `UserControllerTest`
- `WalletControllerTest`
- `JwtServiceTest`
- `TransactionServiceTest`
- `UserServiceTest`
- `WalletServiceTest`

### Integration Tests (Postman)

1. **Setup Postman Collection**:
    - Register User â†’ Login â†’ Create Wallet â†’ Send Transaction

2. **Environment Variables**:
    - `{{username}}, {{email}}, {{password}}, {{jwt_token}}, {{userId}}, {{walletId}}`

3. **Data File Format** (CSV):

```
username,email,password
user_alice,alice@example.com,pass123
user_bob,bob@example.com,pass456
```

4. **Run Collection**:
    - Open Postman â†’ Click "Run" â†’ Select requests and data file â†’ Click Run

This automates full user flow.

---

## Security Considerations

Security is paramount in a cryptocurrency wallet. This project implements several key measures:

- **Strong Key Generation**: Utilizes `java.security.SecureRandom` and `openssl` (via the utility) for generating cryptographically secure random bytes for all secret keys.
- **AES-256 GCM Encryption**: Private keys are encrypted using AES in GCM mode, which provides both confidentiality and data authenticity/integrity.
- **ECDSA (secp256k1) Digital Signatures**: Transactions are digitally signed using ECDSA, ensuring that only the legitimate owner can authorize a transfer and that transaction data remains untampered.
- **JSON Web Tokens (JWT)**: Stateless authentication tokens are used, which are efficient and scalable for distributed systems. JWTs are signed to prevent tampering.
- **Password Hashing**: Passwords are never stored in plaintext. BCrypt is used to hash passwords, making them resistant to rainbow table attacks and brute-force attempts.
- **Stateless Sessions**: By using JWTs and disallowing traditional sessions, the backend avoids session fixation attacks and improves scalability.
- **CSRF Protection Disabled (API-only)**: CSRF protection is explicitly disabled as this is a stateless REST API backend.
- **Secret Key Management**: Environment variables are used for sensitive keys (AES and JWT secrets) to prevent them from being committed directly into the codebase. The `KeyGenerator` utility aids in safely generating these.
- **Replay Attack Prevention**: The unique index on transaction signatures (`@Indexed(unique = true)`) in `TransactionDocument` prevents the same signed transaction from being submitted and processed multiple times.
- **HTTPS (Production Requirement)**: All production deployments **MUST** be served over HTTPS to protect against man-in-the-middle attacks and ensure the confidentiality of JWTs and other sensitive data in transit.

---

## Project Structure

```
â”œâ”€â”€ src/main/java/com/cryptowallet
â”‚   â”œâ”€â”€ config/             # SecurityConfig, CryptoConfig
â”‚   â”œâ”€â”€ controller/         # REST endpoints
â”‚   â”œâ”€â”€ crypto/             # AES, ECDSA logic
â”‚   â”œâ”€â”€ dto/                # Request/response DTOs
â”‚   â”œâ”€â”€ event/              # Domain events
â”‚   â”œâ”€â”€ exception/          # Custom exceptions
â”‚   â”œâ”€â”€ mapper/             # DTO-entity mappers
â”‚   â”œâ”€â”€ merkle/             # Merkle tree classes
â”‚   â”œâ”€â”€ blockchain/         # Block & Blockchain logic
â”‚   â”œâ”€â”€ model/              # MongoDB documents
â”‚   â”œâ”€â”€ repository/         # MongoDB repositories
â”‚   â”œâ”€â”€ service/            # Business logic
â”‚   â””â”€â”€ tool/               # Key generator
â”œâ”€â”€ src/test/               # Unit & integration tests
â”œâ”€â”€ .env                    # Environment variables
â”œâ”€â”€ docker-compose.yml      # Container orchestration
â”œâ”€â”€ pom.xml                 # Maven build file
â””â”€â”€ LICENSE.md              # MIT License
```

---

## Contribution

Contributions are welcome! Please feel free to open issues or submit pull requests.

---
## License

This project is licensed under the terms of the [MIT License](LICENSE.md).